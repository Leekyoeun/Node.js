const fs=require('fs');

console.log('시작');
fs.readFile('./readme2.txt',(err,data)=>{
    if(err){
        throw err;
    }
    console.log('1번', data.toString());
});
fs.readFile('./readme2.txt',(err,data)=>{
    if(err){
        throw err;
    }
    console.log('2번', data.toString());
});
fs.readFile('./readme2.txt',(err,data)=>{
    if(err){
        throw err;
    }
    console.log('3번', data.toString());
});
console.log('끝');

//코드설명
//비동기 메소드들은 백그라운드에 해당 파일을 읽으라고만 요청하고 다음 작업으로 넘어갑니다.
//따라서 파일 읽기 요청만 세 번을 보내고 console.log('끝') 을 찍습니다.
//나중에 읽기가 완료되면 백그라운드가 다사ㅣ 메인 스레드에 알립니다.
//메인 스레드는 그제서야 등록된 콜백 함수를 실행합니다.
//메인 스레드는 백그라운드에 요청 처리를 위임합니다. 그 후로도 얼마든지 요청을 더 받을 수 있습니다.
//나중에 백그라운드가 각각의 요청 처리가 완료되었다고 알리면 그때 콜백 함수를 처리하면 됩니다.

//백그라운드에서는 요청 세 개를 거의 동시에 실행합니다.

//NOTE 동기와 비동기, 블로킹과 논 블로킹
//동기와 비동기, 블로킹과 논 블로킹이라는 네 개의 용어가 노드에서 혼용되고 있으며, 의미도 서로 다릅니다.
//동기와 비동기: 백그라운드 작업 완료 확인 여부
//블로킹과 논블로킹 : 함수가 바로 return되는지 여부
//노드에서는 동기-블로킹 방식과 비동기-논블로킹 방식이 대부분입니다. 동기-논블로킹이나 비동기-블로킹은 없다고 봐도 됩니다.

//동기-블로킹 방식에서는 백그라운드 작업 완료 여부를 계속 확인하며, 호출한 함수가 바로 return되지 않고 백그라운드 작업이 끝나야 return됩니다.
//비동기-논블로킹 방식에서는 호출한 함수가 바로 return처리 되어 다음 작업으로 넘어가며, 백그라운드 작업 완료 여부는 신경쓰지않고 나중에 백그라운드가 알림을 줄 떄 비로소 처리합니다.


